/* Generated from Java with JSweet 1.2.0 - http://www.jsweet.org */
namespace com.jme3.renderer.opengl {
    import IntMap = com.jme3.util.IntMap;

    import Field = java.lang.reflect.Field;

    import InvocationHandler = java.lang.reflect.InvocationHandler;

    import Method = java.lang.reflect.Method;

    import Proxy = java.lang.reflect.Proxy;

    import Buffer = java.nio.Buffer;

    import ByteBuffer = java.nio.ByteBuffer;

    import CharBuffer = java.nio.CharBuffer;

    import DoubleBuffer = java.nio.DoubleBuffer;

    import FloatBuffer = java.nio.FloatBuffer;

    import IntBuffer = java.nio.IntBuffer;

    import LongBuffer = java.nio.LongBuffer;

    import ShortBuffer = java.nio.ShortBuffer;

    import HashMap = java.util.HashMap;

    /**
     * Utility class that allows tracing of OpenGL calls generated by the engine.
     * 
     * @author Kirill Vainer
     */
    export class GLTracer implements InvocationHandler {
        static __static_initialized : boolean = false;
        static __static_initialize() { if(!GLTracer.__static_initialized) { GLTracer.__static_initialized = true; GLTracer.__static_initializer_0(); } }

        private obj : any;

        private constMap : IntMap<string>;

        static nonEnumArgMap : HashMap<string, IntMap<void>>; public static nonEnumArgMap_$LI$() : HashMap<string, IntMap<void>> { GLTracer.__static_initialize(); if(GLTracer.nonEnumArgMap == null) GLTracer.nonEnumArgMap = new HashMap<string, IntMap<void>>(); return GLTracer.nonEnumArgMap; };

        static ANSI_RESET : string = "\u001b[0m";

        static ANSI_BRIGHT : string = "\u001b[1m";

        static ANSI_BLACK : string = "\u001b[30m";

        static ANSI_RED : string = "\u001b[31m";

        static ANSI_GREEN : string = "\u001b[32m";

        static ANSI_YELLOW : string = "\u001b[33m";

        static ANSI_BLUE : string = "\u001b[34m";

        static ANSI_MAGENTA : string = "\u001b[35m";

        static ANSI_CYAN : string = "\u001b[36m";

        static ANSI_WHITE : string = "\u001b[37m";

        private static noEnumArgs(method : string, ...argSlots : number[]) {
            let argSlotsMap : IntMap<void> = <any>(new IntMap<void>());
            for(let index347=0; index347 < argSlots.length; index347++) {
                let argSlot = argSlots[index347];
                {
                    argSlotsMap.put(argSlot, <void>null);
                }
            }
            GLTracer.nonEnumArgMap_$LI$().put(method, argSlotsMap);
        }

        static __static_initializer_0() {
            GLTracer.noEnumArgs("glViewport", 0, 1, 2, 3);
            GLTracer.noEnumArgs("glScissor", 0, 1, 2, 3);
            GLTracer.noEnumArgs("glClear", 0);
            GLTracer.noEnumArgs("glGetInteger", 1);
            GLTracer.noEnumArgs("glGetString", 1);
            GLTracer.noEnumArgs("glBindTexture", 1);
            GLTracer.noEnumArgs("glPixelStorei", 1);
            GLTracer.noEnumArgs("glTexImage2D", 1, 3, 4, 5);
            GLTracer.noEnumArgs("glTexImage3D", 1, 3, 4, 5, 6);
            GLTracer.noEnumArgs("glTexSubImage2D", 1, 2, 3, 4, 5);
            GLTracer.noEnumArgs("glTexSubImage3D", 1, 2, 3, 4, 5, 6, 7);
            GLTracer.noEnumArgs("glCompressedTexImage2D", 1, 3, 4, 5);
            GLTracer.noEnumArgs("glCompressedTexSubImage3D", 1, 2, 3, 4, 5, 6, 7);
            GLTracer.noEnumArgs("glDeleteTextures", 0);
            GLTracer.noEnumArgs("glReadPixels", 0, 1, 2, 3);
            GLTracer.noEnumArgs("glBindBuffer", 1);
            GLTracer.noEnumArgs("glEnableVertexAttribArray", 0);
            GLTracer.noEnumArgs("glDisableVertexAttribArray", 0);
            GLTracer.noEnumArgs("glVertexAttribPointer", 0, 1, 4, 5);
            GLTracer.noEnumArgs("glDrawRangeElements", 1, 2, 3, 5);
            GLTracer.noEnumArgs("glDrawArrays", 1, 2);
            GLTracer.noEnumArgs("glDeleteBuffers", 0);
            GLTracer.noEnumArgs("glBindVertexArray", 0);
            GLTracer.noEnumArgs("glGenVertexArrays", 0);
            GLTracer.noEnumArgs("glBindFramebufferEXT", 1);
            GLTracer.noEnumArgs("glBindRenderbufferEXT", 1);
            GLTracer.noEnumArgs("glRenderbufferStorageEXT", 2, 3);
            GLTracer.noEnumArgs("glRenderbufferStorageMultisampleEXT", 1, 3, 4);
            GLTracer.noEnumArgs("glFramebufferRenderbufferEXT", 3);
            GLTracer.noEnumArgs("glFramebufferTexture2DEXT", 3, 4);
            GLTracer.noEnumArgs("glBlitFramebufferEXT", 0, 1, 2, 3, 4, 5, 6, 7, 8);
            GLTracer.noEnumArgs("glCreateProgram", -1);
            GLTracer.noEnumArgs("glCreateShader", -1);
            GLTracer.noEnumArgs("glShaderSource", 0);
            GLTracer.noEnumArgs("glCompileShader", 0);
            GLTracer.noEnumArgs("glGetShader", 0);
            GLTracer.noEnumArgs("glAttachShader", 0, 1);
            GLTracer.noEnumArgs("glLinkProgram", 0);
            GLTracer.noEnumArgs("glGetProgram", 0);
            GLTracer.noEnumArgs("glUseProgram", 0);
            GLTracer.noEnumArgs("glGetUniformLocation", 0, -1);
            GLTracer.noEnumArgs("glUniformMatrix3", 0);
            GLTracer.noEnumArgs("glUniformMatrix4", 0);
            GLTracer.noEnumArgs("glUniform1i", 0, 1);
            GLTracer.noEnumArgs("glUniform1f", 0);
            GLTracer.noEnumArgs("glUniform2f", 0);
            GLTracer.noEnumArgs("glUniform3f", 0);
            GLTracer.noEnumArgs("glUniform4", 0);
            GLTracer.noEnumArgs("glUniform4f", 0);
            GLTracer.noEnumArgs("glGetAttribLocation", 0, -1);
            GLTracer.noEnumArgs("glDetachShader", 0, 1);
            GLTracer.noEnumArgs("glDeleteShader", 0);
            GLTracer.noEnumArgs("glDeleteProgram", 0);
            GLTracer.noEnumArgs("glBindFragDataLocation", 0, 1);
        }

        public constructor(obj : any, constMap : IntMap<string>) {
            this.obj = obj;
            this.constMap = constMap;
        }

        private static generateConstantMap(...classes : any[]) : IntMap<string> {
            let constMap : IntMap<string> = <any>(new IntMap<string>());
            for(let index348=0; index348 < classes.length; index348++) {
                let clazz = classes[index348];
                {
                    {
                        let array350 = clazz.getFields();
                        for(let index349=0; index349 < array350.length; index349++) {
                            let field = array350[index349];
                            {
                                if(field.getType() === number) {
                                    try {
                                        let val : number = field.getInt(null);
                                        let name : string = field.getName();
                                        constMap.put(val, name);
                                    } catch(__e) {
                                        if(__e != null && __e instanceof java.lang.IllegalArgumentException) {
                                            let ex : java.lang.IllegalArgumentException = <java.lang.IllegalArgumentException>__e;

                                        }
                                        if(__e != null && __e instanceof java.lang.IllegalAccessException) {
                                            let ex : java.lang.IllegalAccessException = <java.lang.IllegalAccessException>__e;

                                        }
                                    };
                                }
                            }
                        }
                    }
                }
            }
            constMap.put(1, "GL_ONE");
            return constMap;
        }

        /**
         * Creates a tracer implementation that wraps OpenGL ES 2.
         * 
         * @param glInterface OGL object to wrap
         * @param glInterfaceClass The interface to implement
         * @return A tracer that implements the given interface
         */
        public static createGlesTracer(glInterface : any, glInterfaceClass : any) : any {
            let constMap : IntMap<string> = GLTracer.generateConstantMap("com.jme3.renderer.opengl.GL", "com.jme3.renderer.opengl.GLFbo", "com.jme3.renderer.opengl.GLExt");
            return Proxy.newProxyInstance((<any>glInterface.constructor).getClassLoader(), [glInterfaceClass], new GLTracer(glInterface, constMap));
        }

        /**
         * Creates a tracer implementation that wraps OpenGL 2+.
         * 
         * @param glInterface OGL object to wrap
         * @param glInterfaceClasses The interface(s) to implement
         * @return A tracer that implements the given interface
         */
        public static createDesktopGlTracer(glInterface : any, ...glInterfaceClasses : any[]) : any {
            let constMap : IntMap<string> = GLTracer.generateConstantMap("com.jme3.renderer.opengl.GL2", "com.jme3.renderer.opengl.GL3", "com.jme3.renderer.opengl.GL4", "com.jme3.renderer.opengl.GLFbo", "com.jme3.renderer.opengl.GLExt");
            return Proxy.newProxyInstance((<any>glInterface.constructor).getClassLoader(), glInterfaceClasses, new GLTracer(glInterface, constMap));
        }

        private printStyle(style : string, string : string) {
            java.lang.System.out.print(style + string + GLTracer.ANSI_RESET);
        }

        private print(string : string) {
            java.lang.System.out.print(string);
        }

        private printInt(value : number) {
            this.print(/* toString */(''+value));
        }

        private printEnum(value : number) {
            let enumName : string = this.constMap.get(value);
            if(enumName != null) {
                if(/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(enumName, "GL_")) {
                    enumName = enumName.substring(3);
                }
                if(/* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(enumName, "_EXT") || /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(enumName, "_ARB")) {
                    enumName = enumName.substring(0, enumName.length - 4);
                }
                this.printStyle(GLTracer.ANSI_GREEN, enumName);
            } else {
                this.printStyle(GLTracer.ANSI_GREEN, "ENUM_" + javaemul.internal.IntegerHelper.toHexString(value));
            }
        }

        private printIntOrEnum(method : string, value : number, argIndex : number) {
            let argSlotMap : IntMap<void> = GLTracer.nonEnumArgMap_$LI$().get(method);
            if(argSlotMap != null && argSlotMap.containsKey(argIndex)) {
                this.printInt(value);
            } else {
                this.printEnum(value);
            }
        }

        private printNewLine() {
            console.info();
        }

        private printString(value : string) {
            if(value.length > 150) {
                value = value.substring(0, 150) + "...";
            }
            let sb : java.lang.StringBuilder = new java.lang.StringBuilder();
            sb.append(GLTracer.ANSI_YELLOW);
            sb.append("\"");
            sb.append(GLTracer.ANSI_RESET);
            {
                let array352 = value.split("\n");
                for(let index351=0; index351 < array352.length; index351++) {
                    let line = array352[index351];
                    {
                        sb.append(GLTracer.ANSI_YELLOW);
                        sb.append(/* replaceAll */line.replace(new RegExp("\u0000", 'g'),"\\\\0"));
                        sb.append(GLTracer.ANSI_RESET);
                        sb.append("\n");
                    }
                }
            }
            if(sb.length() > 1 && sb.charAt(sb.length() - 1) === '\n') {
                sb.setLength(sb.length() - 1);
            }
            sb.append(GLTracer.ANSI_YELLOW);
            sb.append("\"");
            sb.append(GLTracer.ANSI_RESET);
            this.print(sb.toString());
        }

        private printBoolean(bool : boolean) {
            this.printStyle(GLTracer.ANSI_BLUE, bool?"true":"false");
        }

        private printBuffer(buffer : Buffer) {
            let sb : java.lang.StringBuilder = new java.lang.StringBuilder();
            sb.append(GLTracer.ANSI_MAGENTA);
            if(buffer != null && buffer instanceof java.nio.ByteBuffer) {
                sb.append("byte");
            } else if(buffer != null && buffer instanceof java.nio.ShortBuffer) {
                sb.append("short");
            } else if(buffer != null && buffer instanceof java.nio.CharBuffer) {
                sb.append("char");
            } else if(buffer != null && buffer instanceof java.nio.FloatBuffer) {
                sb.append("float");
            } else if(buffer != null && buffer instanceof java.nio.IntBuffer) {
                sb.append("int");
            } else if(buffer != null && buffer instanceof java.nio.LongBuffer) {
                sb.append("long");
            } else if(buffer != null && buffer instanceof java.nio.DoubleBuffer) {
                sb.append("double");
            } else {
                throw new java.lang.UnsupportedOperationException();
            }
            sb.append(GLTracer.ANSI_RESET);
            sb.append("[");
            if(buffer.position() === 0 && buffer.limit() === buffer.capacity()) {
                sb.append(buffer.capacity());
            } else {
                sb.append("pos=").append(buffer.position());
                sb.append(" lim=").append(buffer.limit());
                sb.append(" cap=").append(buffer.capacity());
            }
            sb.append("]");
            this.print(sb.toString());
        }

        private printMethodName(methodName : string) {
            if(/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(methodName, "gl")) {
                methodName = methodName.substring(2);
                if((methodName === "Clear") || (methodName === "DrawRangeElements")) {
                    this.print(methodName);
                } else {
                    if(/* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(methodName, "EXT")) {
                        methodName = methodName.substring(0, methodName.length - 3);
                    }
                    this.printStyle(GLTracer.ANSI_BRIGHT, methodName);
                }
            } else if((methodName === "resetStats")) {
                this.printStyle(GLTracer.ANSI_RED, "-- frame boundary --");
            }
        }

        private printArgsClear(mask : number) {
            let needAPipe : boolean = false;
            this.print("(");
            if((mask & GL.GL_COLOR_BUFFER_BIT) !== 0) {
                this.printStyle(GLTracer.ANSI_GREEN, "COLOR_BUFFER_BIT");
                needAPipe = true;
            }
            if((mask & GL.GL_DEPTH_BUFFER_BIT) !== 0) {
                if(needAPipe) {
                    this.print(" | ");
                }
                this.printStyle(GLTracer.ANSI_GREEN, "DEPTH_BUFFER_BIT");
            }
            if((mask & GL.GL_STENCIL_BUFFER_BIT) !== 0) {
                if(needAPipe) {
                    this.print(" | ");
                }
                this.printStyle(GLTracer.ANSI_GREEN, "STENCIL_BUFFER_BIT");
            }
            this.print(")");
        }

        private printArgsGetInteger(args : any[]) {
            this.print("(");
            let param : number = <number>args[0];
            let ib : IntBuffer = <IntBuffer>args[1];
            this.printEnum(param);
            this.print(", ");
            this.printOut();
            if(param === GL2.GL_DRAW_BUFFER || param === GL2.GL_READ_BUFFER) {
                this.printEnum(ib.get(0));
            } else {
                this.printInt(ib.get(0));
            }
            this.print(")");
        }

        private printArgsTexParameter(args : any[]) {
            this.print("(");
            let target : number = <number>args[0];
            let param : number = <number>args[1];
            let value : number = <number>args[2];
            this.printEnum(target);
            this.print(", ");
            this.printEnum(param);
            this.print(", ");
            if(param === GL.GL_TEXTURE_BASE_LEVEL || param === GL.GL_TEXTURE_MAX_LEVEL) {
                this.printInt(value);
            } else {
                this.printEnum(value);
            }
            this.print(")");
        }

        private printOut() {
            this.printStyle(GLTracer.ANSI_CYAN, "out=");
        }

        private printResult(methodName : string, result : any, returnType : any) {
            if(returnType !== void) {
                this.print(" = ");
                if(typeof result === 'string') {
                    this.printString(<string>result);
                } else if(returnType === number) {
                    let val : number = <number>result;
                    this.printIntOrEnum(methodName, val, -1);
                } else if(returnType === boolean) {
                    this.printBoolean(<boolean>result);
                } else {
                    this.print(" = ???");
                }
            }
        }

        private printNull() {
            this.printStyle(GLTracer.ANSI_BLUE, "null");
        }

        private printArgs(methodName : string, args : any[], paramTypes : any[]) {
            if((methodName === "glClear")) {
                this.printArgsClear(<number>args[0]);
                return;
            } else if((methodName === "glTexParameteri")) {
                this.printArgsTexParameter(args);
                return;
            } else if((methodName === "glGetInteger")) {
                this.printArgsGetInteger(args);
                return;
            }
            if(args == null) {
                this.print("()");
                return;
            }
            this.print("(");
            for(let i : number = 0; i < args.length; i++) {
                if(paramTypes[i] === number) {
                    let val : number = <number>args[i];
                    this.printIntOrEnum(methodName, val, i);
                } else if(paramTypes[i] === boolean) {
                    this.printBoolean(<boolean>args[i]);
                } else if(paramTypes[i] === String) {
                    this.printString(<string>args[i]);
                } else if(paramTypes[i] === String[]) {
                    let arr : string[] = <string[]>args[i];
                    if(arr.length === 1) {
                        this.printString(arr[0]);
                    } else {
                        this.print("string[" + arr.length + "]");
                    }
                } else if(args[i] != null && args[i] instanceof java.nio.IntBuffer) {
                    let buf : IntBuffer = <IntBuffer>args[i];
                    if(buf.capacity() === 16) {
                        let val : number = buf.get(0);
                        this.printOut();
                        this.printIntOrEnum(methodName, val, i);
                    } else if(buf.capacity() === 1) {
                        this.printOut();
                        this.print(/* toString */(''+buf.get(0)));
                    } else {
                        this.printBuffer(buf);
                    }
                } else if(args[i] != null && args[i] instanceof java.nio.ByteBuffer) {
                    let bb : ByteBuffer = <ByteBuffer>args[i];
                    if(bb.capacity() === 250) {
                        this.printOut();
                        this.printBoolean(bb.get(0) !== 0);
                    } else {
                        this.printBuffer(bb);
                    }
                } else if(args[i] != null && args[i] instanceof java.nio.Buffer) {
                    this.printBuffer(<Buffer>args[i]);
                } else if(args[i] != null) {
                    this.print(args[i].toString());
                } else {
                    this.printNull();
                }
                if(i !== args.length - 1) {
                    java.lang.System.out.print(", ");
                }
            }
            this.print(")");
        }

        public invoke(proxy : any, method : Method, args : any[]) : any {
            let methodName : string = method.getName();
            this.printMethodName(methodName);
            if(/* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(methodName, "gl")) {
                try {
                    let result : any = (this['__jswref_0'] = method).invoke.apply(this['__jswref_0'], [this.obj].concat(<any[]>args));
                    this.printArgs(methodName, args, method.getParameterTypes());
                    this.printResult(methodName, result, method.getReturnType());
                    this.printNewLine();
                    return result;
                } catch(ex) {
                    this.printArgs(methodName, args, method.getParameterTypes());
                    this.printNewLine();
                    console.info("\tException occurred!");
                    console.info(ex.toString());
                    throw ex;
                };
            } else {
                this.printNewLine();
                return (this['__jswref_1'] = method).invoke.apply(this['__jswref_1'], [this.obj].concat(<any[]>args));
            }
        }
    }
    GLTracer["__class"] = "com.jme3.renderer.opengl.GLTracer";
    GLTracer["__interfaces"] = ["java.lang.reflect.InvocationHandler"];


}


com.jme3.renderer.opengl.GLTracer.nonEnumArgMap_$LI$();

com.jme3.renderer.opengl.GLTracer.__static_initialize();
